// Image optimization utilities
window.lazyLoadImages={init:function(){const o=new IntersectionObserver((e,t)=>{e.forEach(e=>{if(e.isIntersecting){const t=e.target;t.dataset.src&&(this.loadImage(t),o.unobserve(t))}})},{rootMargin:"50px",threshold:.1});

        // Observe all images with data-src
        document.querySelectorAll('img[data-src]').forEach(img => {
            observer.observe(img);
        });

        // Handle background images
        document.querySelectorAll('[data-bg]').forEach(el => {
            observer.observe(el);
            el.addEventListener('lazyloaded', () => {
                el.style.backgroundImage = `url(${el.dataset.bg})`;
            });
        });
    },

    loadImage: function(img) {
        // Create a new image object
        const newImg = new Image();
        
        newImg.onload = () => {
            img.src = newImg.src;
            img.classList.add('loaded');
            img.dispatchEvent(new CustomEvent('lazyloaded'));
        };

        // Load the image
        newImg.src = img.dataset.src;
        
        // Load srcset if available
        if (img.dataset.srcset) {
            img.srcset = img.dataset.srcset;
        }
    },

    // Preload critical images
    preloadCritical: function() {
        const criticalImages = document.querySelectorAll('img[data-critical]');
        criticalImages.forEach(img => this.loadImage(img));
    }
};

// Initialize lazy loading when the DOM is ready
document.addEventListener('DOMContentLoaded', () => {
    window.lazyLoadImages.init();
    window.lazyLoadImages.preloadCritical();
});
